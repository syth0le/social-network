# Масштабируемая подсистема диалогов
## Цель:
- Отправка сообщения пользователю (метод /dialog/{user_id}/send из спецификации)
- Получение диалога между двумя пользователями (метод /dialog/{user_id}/list из спецификации)
- Обеспечить горизонтальное масштабирование хранилищ на запись с помощью шардинга.
- Предусмотреть: Возможность решардинга

## Реализация:
- в ходе выполнения работы написан микросервис [диалогов](https://github.com/syth0le/dialog-service)
- подключены прометеус и графана для просмотра метрик приложения
- реализован [алгоритм](https://github.com/syth0le/dialog-service/blob/main/internal/storage/sharder/core.go) консистентного хэширования, который размазывает данные по шардам
  - данный подход поможет реализовывать решардинг с меньшими потерями, в отличие от определения через обычное хэширование
- в качестве проверки было имплементировано 2 "шарда"
  - инфраструктурный код, регистрирующий базки в алгоритме консистентного хэширования: [код](https://github.com/syth0le/dialog-service/blob/main/cmd/dialog/application/app.go#L68)
  - компоуз с контейнерами: [код](https://github.com/syth0le/dialog-service/blob/main/docker-compose.yaml)
- реализованы 3 ручки
  - создание диалога `[POST] localhost:8070/dialog`
  - создание сообщения `[POST] localhost:8070/dialog/send`
  - получение сообщений в диалоге `[GET] localhost:8070/dialog/{dialogId}/list`

- ключом шардинга является `dialogID` потому что следует держать все сообщения для одного диалога в одном и том же шарде
- можно было бы сделать размазывание по `dialogID` и времени написания сообщения, но хотелось сделать самописное решение, которое сможет хотя бы базово работать с шардированием
- в качестве продового решения стоит использовать ydb. (ну или монгу, если хочется Nosql решения)
  - данные инструменты из коробки позволяют использовать шардирование, причем без даунтайма
- в моем решении самым простым решением шардирования без даунтайма может быть следующее:
  - создаем N подов с приложением и катим туда новую версию. 
  - создаем копию шардов + новые шарды и решардируемся уже в нее
  - отключаем запись в старой версии и катим решардинг одновременно с этим изменением
  - возможны аномалии и разъезд стейта, на старых данных
  - это достаточно коряво ;) поэтому стоит сразу использовать надстройки над постгрей (не самописные), которые знают в каком шарде сейчас лежат данные. 


## Схема:
![dialog.png](dialog.png)

### Запуск и проверка
1. склонировать данный репозиторий и поднять его с помощью команды `make rebuild`
2. склонировать cервис [диалогов](https://github.com/syth0le/dialog-service) и поднять его с помощью команды `make rebuild`
3. зарегистрироваться в ручке `/user/register` (для проверки будет достаточно двух пользователей).
4. залогиниться и получить свой токен для авторизации для обоих пользователей (в каждом последующем запросе его передавать в заголовке `Authorization`).
5. создать диалог `[POST] localhost:8070/dialog` (в ручке сервиса диалогов) или в `[POST] localhost:8080/dialog`.
6. отправить сообщение в диалог `[POST] localhost:8070/dialog/send` (в ручке сервиса диалогов) или в `[POST] localhost:8080/dialog/send`.
7. получить все сообщения в диалоге `[GET] localhost:8070/dialog/{dialogId}/list` (в ручке сервиса диалогов) или в `[GET] localhost:8080/dialog/{dialogId}/list`.
8. все необходимые ручки есть в [постман коллекции](https://www.postman.com/aerospace-cosmonaut-29691174/workspace/highload-architect/collection/33337980-46a4c50d-5b28-4566-87dd-57e178216abd?action=share&creator=33337980). В работе можно использовать ручки в коллекции `8th hw http collection`.
